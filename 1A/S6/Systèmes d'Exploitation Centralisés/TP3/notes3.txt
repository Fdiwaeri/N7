A l'étape 11.1, on a défini un traitement des signaux SIGINT(Ctrl+C) et 
SIGTSTP(Ctrl+Z) qui permet la suspension ou la terminaison des percessus fils
sans celles du minishell, avec affichage de reception de ces signaux.
"// Etape 11.1
 else if (signal == SIGTSTP) {
    printf("\nsignal SIGTSTP reçu\n");
    printf("> ");
} else if (signal == SIGINT) {
    printf("\nsignal SIGINT reçu\n");
    printf("> ");
}"
dans main:
// Etaoe 11.1
//on effectue le traitement de sigaction aux signaux SIGINT et SIGTSTP
if (sigaction(SIGINT, &action_sig, NULL) == -1) {
    perror("erreur de sigaction pour SIGINT");
    exit(EXIT_FAILURE);
}
if (sigaction(SIGTSTP, &action_sig, NULL) == -1) {
    perror("erreur de sigaction pour SIGTSTP");
    exit(EXIT_FAILURE);
}
A l'étape 11.2 (on ajoute #include <signal.h> pour pouvoir utiliser la primitive signal)
Avant le fork, pour que ce traitement soit hérité:
// Etape 11.2
if (signal(SIGINT, SIG_IGN) == SIG_ERR) {
    perror("erreur de signal pour SIGINT");
    exit(EXIT_FAILURE);
}

if (signal(SIGTSTP, SIG_IGN) == SIG_ERR) {
    perror("erreur de signal pour SIGTSTP");
    exit(EXIT_FAILURE);
}
Pour qu'il soit pas hérité par le processus fils, on le redéfinit pour un 
traitement par défaut avant l'exécution de la commande dans le fils:
/ Etape 11.2
// pour que le traitement du père ne soit pas
// hérité par le fils, on le redéfinit
if (signal(SIGINT, SIG_DFL) == SIG_ERR) {
    perror("erreur de signal pour SIGINT");
    exit(EXIT_FAILURE);
}

if (signal(SIGTSTP, SIG_DFL) == SIG_ERR) {
    perror("erreur de signal pour SIGTSTP");
    exit(EXIT_FAILURE);
}

A l'étape 11.3:
// Masquer les signaux SIGINT et SIGTSTP
sigset_t mask;
sigemptyset(&mask);
sigaddset(&mask, SIGINT);
sigaddset(&mask, SIGTSTP);

if (sigprocmask(SIG_BLOCK, &mask, NULL) == -1) {
    perror("erreur de sigprocmask");
    exit(EXIT_FAILURE);
}
