#include <stdio.h>
#include <stdlib.h>
#include "readcmd.h"
#include <stdbool.h>
#include <string.h>
#include <unistd.h>     // fork, getpid, getppid
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>    // signal et sigprocmask
#include <fcntl.h>     // open et ses flags
#include <dirent.h>    // les fonctions de manipulation de répertoires

void traitement_signal(int signal) {
    int status;
    pid_t pid;
    if (signal == SIGCHLD) {
        while ((pid = waitpid(-1, &status, WNOHANG|WUNTRACED|WCONTINUED)) > 0) {
            printf("Le processus fils %d a changé d'état: ", pid);
            if (WIFEXITED(status)){
                printf("il s'est terminé avec le code %i\n", WEXITSTATUS(status));
            } else if (WIFSIGNALED(status)) {
                printf("il s’est terminé (killed) par le signal %i\n", WTERMSIG(status));
            } else if (WIFSTOPPED(status)) {
                printf("il s'est suspendu par le signal\n");
            } else if (WIFCONTINUED(status)) {
                printf("il continue\n");
            }
        }
    }
}

void changer_rep(const char *nouv_rep){
    
    // le cas ou aucun argument nouv_rep n'est donné
    if (nouv_rep == NULL){
        char *rep_racine;
        rep_racine = getenv("HOME");
        if (rep_racine == NULL){
            perror("répertoire racine non existant");
            return;
        }
        if (chdir(rep_racine) == -1){
            perror("erreur chdir");
            return;
        }
    } else{
        if (chdir(nouv_rep) == -1){
            perror("erreur chdir");
            return;
        }
    }  
}


void afficher_rep(const char *rep){
    DIR *repertoire;
    struct dirent *entree;
    
    // le cas ou aucun argument rep n'est donné
    if (rep == NULL){
        char *rep_courant = getcwd(NULL, 0);
        if (rep_courant == NULL){
            perror("erreur getcwd");
            return;
        }
        rep = rep_courant;
    }
    repertoire = opendir(rep);
    
    printf("Le contenu de %s est:\n", rep);
    while ((entree = readdir(repertoire)) != NULL){
        printf("%s\n", entree->d_name);
    }
    
    if (closedir(repertoire) == -1){
        perror("erreur closedir");
        return;
    }
    printf("Fin d'affichage\n");
}


// Etapes 16 et 17
// Pour éviter la redondance dans le code, on définit la fonction
// executer_commande pour ecécuter une commande dans un prcessus
void executer_commande(char **cmd, struct cmdline *commande, int tube_entree, int tube_sortie) {
    // création du processus fils
    pid_t pid = fork();
    if (pid == -1) {
        printf("Erreur fork\n");
        exit(EXIT_FAILURE);
    } else if (pid == 0) {
        // processus fils
        
        // Etape 11.3
        sigset_t masque_fils;
        sigemptyset(&masque_fils);
        
        if (sigprocmask(SIG_SETMASK, &masque_fils, NULL) == -1) {
            perror("erreur démasquage signaux dans le fils");
            exit(EXIT_FAILURE);
        }
        
        // Etape 12
        // les processus en arrière plan doivent etre
        // insensibles
        if (commande->backgrounded != NULL) {
            // mettre les processus en arrière plan dans
            // un nouveau groupe
            if (setpgrp() == -1) {
                perror("erreur setpgrp");
                exit(EXIT_FAILURE);
            }
        }
        
        // Etape 13
        int entree, sortie;
        
        // entrée depuis un tube => remplacer l'entrée standard
        if (tube_entree != -1) {
            if (dup2(tube_entree, STDIN_FILENO) == -1) {
                perror("erreur dup2 tube d'entrée");
                exit(EXIT_FAILURE);
            }
            close(tube_entree);
        }
        
        // sortie vers un tube => remplacer la sortie standard
        if (tube_sortie != -1) {
            if (dup2(tube_sortie, STDOUT_FILENO) == -1) {
                perror("erreur dup2 tube de sortie");
                exit(EXIT_FAILURE);
            }
            close(tube_sortie);
        }
        
        // Association de l'entrée standard de la commande
        if (commande->in != NULL){
            if ((entree = open(commande->in, O_RDONLY)) == -1){
                perror("erreur open commande->in");
                exit(EXIT_FAILURE);
            }
            if ((dup2(entree, STDIN_FILENO)) == -1){
                printf("erreur dup2 %s", commande->in);
                exit(EXIT_FAILURE);
            }
            close(entree);
        }
        
        // Association de la sortie standard de la commande
        if (commande->out != NULL){
            if ((sortie = open(commande->out, O_WRONLY|O_CREAT|O_TRUNC, 0644)) == -1){
                perror("erreur open commande->out");
                exit(EXIT_FAILURE);
            }
            if ((dup2(sortie, STDOUT_FILENO)) == -1){
                printf("erreur dup2 %s", commande->out);
                exit(EXIT_FAILURE);
            }
            close(sortie);
        }
        
        // exécuter la commande
        if (execvp(cmd[0], cmd) == -1) {
            perror("Erreur execvp");
            exit(EXIT_FAILURE);
        }
    }
    // processus père
    
    // fermer l'entrée et sortie du tube
    if (tube_entree != -1) {
        close(tube_entree);
    }
    if (tube_sortie != -1) {
        close(tube_sortie);
    }
    
    return;
}

int main(void) {

    struct sigaction action_sig;
    action_sig.sa_handler = traitement_signal;
    sigemptyset(&action_sig.sa_mask);
    action_sig.sa_flags = SA_RESTART;

    if (sigaction(SIGCHLD, &action_sig, NULL) == -1) {
        perror("erreur de sigaction pour SIGCHLD");
        exit(EXIT_FAILURE);
    }
    
    //Etape 11.3
    sigset_t masque;
    sigemptyset(&masque); // notre set <- 0
    sigaddset(&masque, SIGINT); // ajouter Ctrl+C au set
    sigaddset(&masque, SIGTSTP); // ajouter Ctrl+Z  au set
    
    if (sigprocmask(SIG_BLOCK, &masque, NULL) == -1) {
        perror("erreur de sigprocmask");
        exit(EXIT_FAILURE);
    }

    bool fini= false;

    while (!fini) {
        printf("> ");
        struct cmdline *commande= readcmd();

        if (commande == NULL) {
            // commande == NULL -> erreur readcmd()
            perror("erreur lecture commande");
            exit(EXIT_FAILURE);
    
        } else {

            if (commande->err) {
                // commande->err != NULL -> commande->seq == NULL
                printf("erreur saisie de la commande : %s\n", commande->err);
        
            } else {
                
                // Etape 16
                // Compter le nombre de commandes à exécuter
                int nb_commandes = 0;
                while (commande->seq[nb_commandes] != NULL) {
                    nb_commandes++;
                }
                
                if (nb_commandes == 0) {
                    continue;
                }
                
                // 1er cas: une seule commande
                if (nb_commandes == 1) {
                    char **cmd = commande->seq[0];
                    
                    if (cmd[0]) {
                        if (strcmp(cmd[0], "exit") == 0) {
                            fini= true;
                            printf("Au revoir ...\n");
                        }
                        // Etape 14
                        else if (strcmp(cmd[0], "cd") == 0) {
                            printf("commande : ");
                            int indexcmd= 0;
                            while (cmd[indexcmd]) {
                                printf("%s ", cmd[indexcmd]);
                                indexcmd++;
                            }
                            printf("\n");
                            changer_rep(cmd[1]);
                        }
                        // Etape 15
                        else if (strcmp(cmd[0], "dir") == 0) {
                            printf("commande : ");
                            int indexcmd= 0;
                            while (cmd[indexcmd]) {
                                printf("%s ", cmd[indexcmd]);
                                indexcmd++;
                            }
                            printf("\n");
                            afficher_rep(cmd[1]);
                        }
                        else {
                            printf("commande : ");
                            int indexcmd= 0;
                            while (cmd[indexcmd]) {
                                printf("%s ", cmd[indexcmd]);
                                indexcmd++;
                            }
                            printf("\n");
                            
                            // Etape 11.3
                            if (sigprocmask(SIG_BLOCK, &masque, NULL) == -1) {
                                perror("erreur de sigprocmask");
                                exit(EXIT_FAILURE);
                            }
                            
                            // Appel à executer_commande
                            // pas de tubes, donc tube_entree=tube_sortie=-1
                            executer_commande(cmd, commande, -1, -1);
                            
                            // processus père
                            // wait(&status);  --avant on attendait toujours
                                             // l'execution de la commande

                            if (commande->backgrounded == NULL) {
                                // Commande en avant-plan
                                // Option1: Il faut attendre la fin
                                // waitpid(pid, &status, 0);
                                
                                // Option2: utiliser void pause()
                                pause();
                                
                            }
                        }
                    }
                }
                
                // 2eme cas: 2 commandes ou plus
                else if (nb_commandes>1) {
                    // on affiche les commandes
                    printf("commandes : ");
                    for (int i = 0; i < nb_commandes; i++) {
                        char **cmd = commande->seq[i];
                        int indexcmd= 0;
                        while (cmd[indexcmd]) {
                            printf("%s ", cmd[indexcmd]);
                            indexcmd++;
                        }
                        if (i< nb_commandes - 1){
                            printf(" | ");
                        }
                    }
                    printf("\n");
                    
                    // Etape 11.3 (appliquée pour le 2eme cas)
                    if (sigprocmask(SIG_BLOCK, &masque, NULL) == -1) {
                        perror("erreur de sigprocmask");
                        exit(EXIT_FAILURE);
                    }
                    
                    // Etape 17
                    // création des tubes pour les commandes
                    // pour n commandes, on a besoin de n-1 tubes
                    int tubes[nb_commandes - 1][2];
                    for (int i = 0; i < nb_commandes - 1; i++) {
                        if (pipe(tubes[i]) == -1) {
                            perror("erreur pipe");
                            exit(EXIT_FAILURE);
                        }
                    }
                    
                    // Exécution des commandes avec les tubes
                    for (int i = 0; i < nb_commandes; i++) {
                        char **cmd = commande->seq[i];
                        
                        // initialisation des entrés et sorties
                        int tube_entree = -1;
                        int tube_sortie = -1;
                        
                        // Si ce n'est pas la première commande
                        if (i > 0) {
                            // l'entrée est la sortie du tube précédent
                            tube_entree = tubes[i-1][0];
                        }
                        
                        // Si ce n'est pas la dernière commande
                        if (i < nb_commandes - 1) {
                            // la sortie est la sortie du tube courant
                            tube_sortie = tubes[i][1];
                        }
                        
                        // Exécuter la commande courante
                        executer_commande(cmd, commande, tube_entree, tube_sortie);
                    }
                    
                    // fermer tous les tubes dans le processus père
                    for (int i = 0; i < nb_commandes - 1; i++) {
                        close(tubes[i][0]);
                        close(tubes[i][1]);
                    }
                    
                    // attendre si commande en avant-plan
                    if (commande->backgrounded == NULL) {
                        pause();
                    }
                }
            }
        }
    }
    return EXIT_SUCCESS;
}
