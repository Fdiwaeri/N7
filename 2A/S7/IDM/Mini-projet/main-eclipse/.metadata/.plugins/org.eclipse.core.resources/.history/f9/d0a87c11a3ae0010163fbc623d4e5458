-- @path SimplePDL=/fr.n7.simplePDL/SimplePDL.ecore
-- @path PetriNet=/fr.n7.petriNet/PetriNet.ecore

module simplepdl2petrinet;
create OUT : PetriNet from IN : SimplePDL;

-- Helper conservé (getProcess)
helper context SimplePDL!ProcessElement
def: getProcess() : SimplePDL!Process =
SimplePDL!Process.allInstances()->select(e | e.processElements->includes(self));

-- Règle Process2PetriNet corrigée pour la contenance 
rule Process2PetriNet {
	from p: SimplePDL!Process
	to petrinet: PetriNet!PetriNet (
		name <- p.name,
		-- La liste des éléments est construite en collectant les résultats de transformation
        -- de tous les ProcessElements (WD, WS, Ressource) et des UtilisationRessources.
        petrinetelement <- 
            p.processElements
                ->union(SimplePDL!UtilisationRessources.allInstances())
                ->collect(e | thisModule.resolveTemp(e))
                ->flatten()
		)
}

--Pour chaque élément WorkDefinition, on veut créer un élément motif de mme nom.
rule WD2PetriNet {
	from wd : SimplePDL!WorkDefinition
	to
	--Place [cite: 17]
 	 p_ready: PetriNet!Place(
 		  name <- wd.name + '_ready',
 		  jetons <- 1),
 		 
 			
  	 p_running: PetriNet!Place(
  		 name <- wd.name + '_running',
  		 jetons <- 0),
 	
  	 p_finished: PetriNet!Place(
  		 name <- wd.name + '_finished',
  		 jetons <- 0),
 		
  	 p_started: PetriNet!Place(
  		 name <- wd.name + '_started',
  		 jetons <- 0),
 		
	--Transitions
  
 	t_start: PetriNet!Transition(name <- wd.name + '_start'), 		
    t_finish: PetriNet!Transition(name <- wd.name + '_finish'),
	
 	--Arcs [cite: 18]
	
 	 e_r_s: PetriNet!Arc(
 	 	type <- #normal,
  		 entree <- p_ready,
  		 sortie <- t_start,
  		 poids <- 1
  		 ),
 	
 	 e_s_sd: PetriNet!Arc(
 	 	 type <- #normal,
  		 entree <- t_start,
  		 sortie <- p_started,
  		 poids <- 1
  		),
 	
  	 e_s_rg: PetriNet!Arc(
  	 	type <- #normal,
  		 entree <- t_start,
  		 sortie <- p_running,
  		 poids <- 1
  		 ),
 	
  	 e_rg_f: PetriNet!Arc(
  	 	type <- #normal,
  		 entree <- p_running,
  		 sortie <- t_finish,
  		 poids <- 1
  		 
),
 	
  	 e_f_fd: PetriNet!Arc(
  	 	 type <- #normal,
  		 entree <- t_finish,
  		 sortie <- p_finished,
  		 poids <- 1
  		)
}


rule WorkSequence2PetriNet {
	from ws: SimplePDL!WorkSequence
	to
		Arc_ws : PetriNet!Arc(type <- #readArc
			,poids <- 1
			,entree <- thisModule.resolveTemp(ws.predecessor,'p'+
				(if ((ws.linkType = #finishToFinish) or (ws.linkType = #finishToStart))
					then '_finished'
					else  '_started'
					endif))
			,sortie <- thisModule.resolveTemp(ws.successor,'t' + 
				(if ((ws.linkType = #finishToStart) or (ws.linkType = #startToStart))
					then  '_start'
					else '_finish'
					endif))
					)
}

rule R2PetriNet {
	from ressource: SimplePDL!Ressource    
	to
  	  p_ressource: PetriNet!Place(name <- ressource.name,
  	  	jetons <- ressource.quantite)
}

rule rs2PetriNet {
	from amount : SimplePDL!UtilisationRessources
	to
	a_demande : PetriNet!Arc(
  	  type <- #normal ,
 
  	  entree <- amount.ressource,
  	  sortie <-thisModule.resolveTemp(amount.workdefinition,'t_start'),
	  poids <- amount.nbOccurences
  	  ),
	a_libere :  PetriNet!Arc(
  	  type <- #normal ,
  	  sortie <- amount.ressource,
  	  entree <-thisModule.resolveTemp(amount.workdefinition,'t_finish'),
	  poids <- amount.nbOccurences
  	  )  		 
  	 
}