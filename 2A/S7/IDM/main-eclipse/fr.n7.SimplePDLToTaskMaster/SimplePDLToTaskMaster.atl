-- @path SimplePDL=file:/home/fek2775/Annee_2/IDM2023/fr.n7.simplePDL2/SimplePDL.ecore
-- @path TM=file:/home/fek2775/Annee_2/IDM2023/fr.n7.taskMaster/model/TaskMaster.ecore

module SimplePDLToTaskMaster;
create OUT : TM from IN : SimplePDL;

-- Helper pour les WorkDefinitions, WorkSequences (qui sont ProcessElements)
helper context SimplePDL!ProcessElement
def: getProcess() : SimplePDL!Process =
	SimplePDL!Process.allInstances()->select(e | e.processElements->includes(self))->asSequence()->first();

rule Process2EventBundle {
	from process : SimplePDL!Process
	to bundle : TM!EventBundle(name <- process.name)
}

rule WD2Task {
	from wd : SimplePDL!WorkDefinition
	to
		event_start : TM!Event(bundle <- wd.getProcess(), name <- wd.name + '_start'),
		event_finish: TM!Event(bundle <- wd.getProcess(), name <- wd.name + '_finish'),
		finish_after_start: TM!Causal(event <- event_finish, target <- event_start)
}


-- WS
-- Helper pour déterminer le suffixe de l'événement (start ou finish) à partir du linkType
helper context SimplePDL!WorkSequence
def: getEventSuffix(isSource : Boolean) : String =
    if isSource then
        -- Source de la WorkSequence (prédécesseur)
        if self.linkType = #s2s or self.linkType = #s2f then
            'start'
        else -- #f2s or #f2f
            'finish'
        endif
    else
        -- Target de la WorkSequence (successeur)
        if self.linkType = #s2s or self.linkType = #f2s then
            'start'
        else -- #s2f or #f2f
            'finish'
        endif
    endif;

rule WS2Requirement {
    from ws : SimplePDL!WorkSequence
    to
        req : TM!Causal (
            -- Événement dépendant (event) : l'événement du successeur (target de WS)
            event <- thisModule.resolveTemp(
                ws.successor, 
                'event_' + ws.getEventSuffix(false) -- Utiliser getEventSuffix(false) pour le successeur
            ),
            -- Événement cause (target) : l'événement du prédécesseur (source de WS)
            target <- thisModule.resolveTemp(
                ws.predecessor, 
                'event_' + ws.getEventSuffix(true) -- Utiliser getEventSuffix(true) pour le prédécesseur
            )
        )
}


-- Helper pour les Resources
helper context SimplePDL!Resource
def: getProcess() : SimplePDL!Process =
	SimplePDL!Process.allInstances()->select(e | e.resources->includes(self))->asSequence()->first();

-- Ressources
rule Resource2Supply {
    from res : SimplePDL!Resource
    to
        supply : TM!Supply (
            -- Attributs de Supply :
            name       <- res.name,
            available  <- res.quantity,
            consumable <- false, -- Hypothèse: toutes les ressources sont non-consommables par défaut
            -- Rattachement au EventBundle parent
            bundle     <- res.getProcess() 
        )
}

rule UsageResource2Physical {
    from ur : SimplePDL!UsageResource
    to
        physical_req : TM!Physical (
            -- Attributs de Physical :
            requested <- ur.usageQuantity,
            -- Références :
            -- L'événement dépendant (event) : l'événement de DÉBUT de la WorkDefinition
            event     <- thisModule.resolveTemp(
                ur.workdefinition, 
                'event_start' 
            ),
            -- Le Supply cible (target) : le résultat de la transformation de la Resource
            target    <- ur.resource
        )
}