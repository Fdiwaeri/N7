-- @path SimplePDL=file:/home/fek2775/Annee_2/IDM2023/fr.n7.simplePDL2/SimplePDL.ecore
-- @path PN=file:/home/fek2775/Annee_2/IDM2023/fr.n7.petriNet/PetriNet.ecore

module SimplePDLToPetriNet;
create OUT : PN from IN : SimplePDL;

-- Helpers mis à jour pour les 2 transitions (start et finish)
helper context SimplePDL!WorkDefinition
def: getStartTransition() : PN!Transition =
    thisModule.resolveTemp(self, 'startTransition');

helper context SimplePDL!WorkDefinition
def: getFinishTransition() : PN!Transition =
    thisModule.resolveTemp(self, 'finishTransition');

-- Helpers pour les 4 places
helper context SimplePDL!WorkDefinition
def: getReadyPlace() : PN!Place =
    thisModule.resolveTemp(self, 'readyPlace');
    
helper context SimplePDL!WorkDefinition
def: getStartedPlace() : PN!Place =
    thisModule.resolveTemp(self, 'startedPlace');

helper context SimplePDL!WorkDefinition
def: getRunningPlace() : PN!Place =
    thisModule.resolveTemp(self, 'runningPlace');
    
helper context SimplePDL!WorkDefinition
def: getFinishedPlace() : PN!Place =
    thisModule.resolveTemp(self, 'finishedPlace');

-- Règle Process2PetriNet inchangée (Process devient PetriNet)
rule Process2PetriNet {
    from
        process : SimplePDL!Process
    to
        petriNet : PN!PetriNet (
            name <- process.name + ' - PetriNet',
            
            -- Rattachement des Places (PN!Place)
            places <- (
                        process.processElements->select(e | e.oclIsKindOf(SimplePDL!WorkDefinition))
                        ->collect(wd | 
                            -- Création de la collection des 4 places
                            Sequence{thisModule.resolveTemp(wd, 'readyPlace')}
                            + Sequence{thisModule.resolveTemp(wd, 'startedPlace')}
                            + Sequence{thisModule.resolveTemp(wd, 'runningPlace')}
                            + Sequence{thisModule.resolveTemp(wd, 'finishedPlace')}
                        )
                        -- NOUVEAU: Aplatissement des collections créées pour les WD
                        ->flatten() 
                    )
                    -- Les places créées pour les ressources (Resource2Place). On peut utiliser collect car il retourne une collection simple ici.
                    + process.resources->collect(res | thisModule.resolveTemp(res, 'place')),
            
            -- Rattachement des Transitions (PN!Transition)
            transitions <- process.processElements->select(e | e.oclIsKindOf(SimplePDL!WorkDefinition))
                    ->collect(wd | 
                        -- Création de la collection des 2 transitions
                        Sequence{thisModule.resolveTemp(wd, 'startTransition')}
                        + Sequence{thisModule.resolveTemp(wd, 'finishTransition')}
                    )
                    -- NOUVEAU: Aplatissement des collections
                    ->flatten(),
            
            -- Rattachement des Arcs (PN!Arc)
            arcs <- (
                        process.processElements->select(e | e.oclIsKindOf(SimplePDL!WorkDefinition))
                        ->collect(wd | 
                            -- 5 Arcs internes de WD2Nodes
                            Sequence{thisModule.resolveTemp(wd, 'readyToStartArc')}
                            + Sequence{thisModule.resolveTemp(wd, 'startToRunningArc')}
                            + Sequence{thisModule.resolveTemp(wd, 'startToStartedArc')}
                            + Sequence{thisModule.resolveTemp(wd, 'runningToFinishArc')}
                            + Sequence{thisModule.resolveTemp(wd, 'finishToFinishedArc')}
                            -- Arcs de UsageResource2Arcs
                            + wd.uses->collect(ur | 
                                -- Ici, on peut laisser le 'collect' retourner les éléments individuels
                                Sequence{thisModule.resolveTemp(ur, 'consumeArc')}
                                + Sequence{thisModule.resolveTemp(ur, 'releaseArc')}
                            )
                            -- NOUVEAU: flatten est nécessaire à cause de la concaténation + au niveau supérieur du collect
                        )
                        ->flatten()
                    )
                    -- Ajout des Arcs créés par WorkSequence (WS2Arc_...)
                    + process.processElements->select(e | e.oclIsKindOf(SimplePDL!WorkSequence))
                    ->collect(ws | thisModule.resolveTemp(ws, 'arc'))
        )
}

rule WD2Nodes {
    from
        wd : SimplePDL!WorkDefinition
    to
        -- Les deux transitions
        startTransition : PN!Transition (
            name <- wd.name + '_start'
        ),
        finishTransition : PN!Transition (
            name <- wd.name + '_finish'
        ),
        
        -- Les quatre places
        readyPlace : PN!Place (
            name <- wd.name + '_ready',
            initialMarketing <- 1 -- La tâche est initialement prête
        ),
        startedPlace : PN!Place (
            name <- wd.name + '_started',
            initialMarketing <- 0
        ),
        runningPlace : PN!Place (
            name <- wd.name + '_running',
            initialMarketing <- 0
        ),
        finishedPlace : PN!Place (
            name <- wd.name + '_finished',
            initialMarketing <- 0
        ),
        
        -- Arcs internes de la WorkDefinition (selon la syntaxe Tina fournie)
        
        -- Arc 1: ready -> startTransition
        readyToStartArc : PN!ArcPlaceTransition (
            source <- readyPlace,
            target <- startTransition,
            weight <- 1
        ),
        -- Arc 2: startTransition -> running
        startToRunningArc : PN!ArcTransitionPlace (
            source <- startTransition,
            target <- runningPlace,
            weight <- 1
        ),
        -- Arc 3: startTransition -> started
        startToStartedArc : PN!ArcTransitionPlace (
            source <- startTransition,
            target <- startedPlace,
            weight <- 1
        ),
        -- Arc 4: running -> finishTransition
        runningToFinishArc : PN!ArcPlaceTransition (
            source <- runningPlace,
            target <- finishTransition,
            weight <- 1
        ),
        -- Arc 5: finishTransition -> finished
        finishToFinishedArc : PN!ArcTransitionPlace (
            source <- finishTransition,
            target <- finishedPlace,
            weight <- 1
        )
}

rule WS2Arc_FinishToStart {
    from
        ws : SimplePDL!WorkSequence (ws.linkType = #finishToStart)
    to
        -- Arc de la fin du prédécesseur (finished) vers le début du successeur (start)
        arc : PN!ArcPlaceTransition
        (
            -- Le prédécesseur doit être terminé. La place source est 'finished'
            source <- ws.predecessor.getFinishedPlace(), 
            -- Le successeur peut commencer. La transition cible est 'start'
            target <- ws.successor.getStartTransition(),
            weight <- 1
        )
}

rule WS2Arc_StartToStart {
    from
        ws : SimplePDL!WorkSequence (ws.linkType = #startToStart)
    to
        -- Arc du début du prédécesseur (started) vers le début du successeur (start)
        arc : PN!ArcPlaceTransition
        (
            -- Le prédécesseur doit être démarré. La place source est 'started'
            source <- ws.predecessor.getStartedPlace(), 
            -- Le successeur peut commencer. La transition cible est 'start'
            target <- ws.successor.getStartTransition(),
            weight <- 1
        )
}

rule WS2Arc_FinishToFinish {
    from
        ws : SimplePDL!WorkSequence (ws.linkType = #finishToFinish)
    to
        -- Arc de la fin du prédécesseur (finished) vers la fin du successeur (finish)
        arc : PN!ArcPlaceTransition
        (
            -- Le prédécesseur doit être terminé. La place source est 'finished'
            source <- ws.predecessor.getFinishedPlace(), 
            -- Le successeur peut se terminer. La transition cible est 'finish'
            target <- ws.successor.getFinishTransition(),
            weight <- 1
        )
}

rule WS2Arc_StartToFinish {
    from
        ws : SimplePDL!WorkSequence (ws.linkType = #startToFinish)
    to
        -- Arc du début du prédécesseur (started) vers la fin du successeur (finish)
        arc : PN!ArcPlaceTransition
        (
            -- Le prédécesseur doit être démarré. La place source est 'started'
            source <- ws.predecessor.getStartedPlace(), 
            -- Le successeur peut se terminer. La transition cible est 'finish'
            target <- ws.successor.getFinishTransition(),
            weight <- 1
        )
}

-- Règle Resource2Place inchangée
rule Resource2Place {
    from
        res : SimplePDL!Resource
    to
        place : PN!Place (
            name <- res.name,
            initialMarketing <- res.quantity
        )
}

-- Règle UsageResource2Arcs mise à jour pour utiliser les transitions 'start' et 'finish'
rule UsageResource2Arcs {
    from
        ur : SimplePDL!UsageResource
    to
        -- Arc 1: Consommation (Place -> Transition 'start') : consomme au début de l'activité
        consumeArc : PN!ArcPlaceTransition (
            source <- ur.resource, 
            target <- ur.workdefinition.getStartTransition(), -- Consomme à la transition 'start'
            weight <- ur.UsageQuantity
        ),
        
        -- Arc 2: Libération (Transition 'finish' -> Place) : libère à la fin de l'activité
        releaseArc : PN!ArcTransitionPlace (
            source <- ur.workdefinition.getFinishTransition(), -- Libère à la transition 'finish'
            target <- ur.resource,
            weight <- ur.UsageQuantity
        )
}